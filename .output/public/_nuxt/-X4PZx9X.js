const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./Bc_z7frc.js","./AebXkaNM.js","./BzQlD_xP.js","./entry.Bc7Sv5ip.css"])))=>i.map(i=>d[i]);
import{Z as ie}from"./BzQlD_xP.js";import{r as oe,C as ae}from"./AebXkaNM.js";class ce{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=e??!0;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async createConnection(e,t,r,i,n){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:r,version:i,readonly:n});const a=new W(e,n,this.sqlite),o=n?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(o,a),Promise.resolve(a)}catch(a){return Promise.reject(a)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const r=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(r),Promise.resolve()}catch(r){return Promise.reject(r)}}async isConnection(e,t){const r={};e.endsWith(".db")&&(e=e.slice(0,-3));const i=t?`RO_${e}`:`RW_${e}`;return r.result=this._connectionDict.has(i),Promise.resolve(r)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(r)){const i=this._connectionDict.get(r);return typeof i<"u"?Promise.resolve(i):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const r=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const r=new W(e,!0,this.sqlite),i=`RO_${e})`;return this._connectionDict.set(i,r),Promise.resolve(r)}catch(r){return Promise.reject(r)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},r=`RO_${e})`;return t.result=this._connectionDict.has(r),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,r=this._connectionDict.get(t);return typeof r<"u"?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const r=t.substring(3),i=t.substring(0,3)==="RO_";await this.sqlite.closeConnection({database:r,readonly:i}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],r=[];for(const n of e)t.push(n.substring(0,2)),r.push(n.substring(3));const i=await this.sqlite.checkConnectionsConsistency({dbNames:r,openModes:t});return i.result||(this._connectionDict=new Map),Promise.resolve(i)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=e??!0;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async getFromHTTPRequest(e,t){const r=t??!0;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:r}),Promise.resolve()}catch(i){return Promise.reject(i)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const t=(await this.sqlite.getDatabaseList()).values;t.sort();const r={values:t};return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const r=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async addSQLiteSuffix(e,t){const r=e||"default",i=t||[];try{const n=await this.sqlite.addSQLiteSuffix({folderPath:r,dbNameList:i});return Promise.resolve(n)}catch(n){return Promise.reject(n)}}async deleteOldDatabases(e,t){const r=e||"default",i=t||[];try{const n=await this.sqlite.deleteOldDatabases({folderPath:r,dbNameList:i});return Promise.resolve(n)}catch(n){return Promise.reject(n)}}async moveDatabasesAndAddSuffix(e,t){const r=e||"default",i=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:r,dbNameList:i})}}class W{constructor(e,t,r){this.dbName=e,this.readonly=t,this.sqlite=r}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,r=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const i=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:r});return Promise.resolve(i)}}catch(i){return Promise.reject(i)}}async query(e,t,r=!0){let i;try{return t&&t.length>0?i=await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):i=await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:r}),i=await this.reorderRows(i),Promise.resolve(i)}catch(n){return Promise.reject(n)}}async run(e,t,r=!0,i="no",n=!0){let a;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?a=await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:r,readonly:!1,returnMode:i,isSQL92:!0}):a=await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:r,readonly:!1,returnMode:i,isSQL92:n}),a.changes=await this.reorderRows(a.changes),Promise.resolve(a))}catch(o){return Promise.reject(o)}}async executeSet(e,t=!0,r="no",i=!0){let n;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(n=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:r,isSQL92:i}),n.changes=await this.reorderRows(n.changes),Promise.resolve(n))}catch(a){return Promise.reject(a)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const r=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let r=0,i=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),i=await this.sqlite.isTransactionActive({database:this.dbName}),!i)return Promise.reject("After Begin Transaction, no transaction active");try{for(const o of e){if(typeof o!="object"||!("statement"in o))throw new Error("Error a task.statement must be provided");if("values"in o&&o.values&&o.values.length>0){const m=o.statement.toUpperCase().includes("RETURNING")?"all":"no",p=await this.sqlite.run({database:this.dbName,statement:o.statement,values:o.values,transaction:!1,readonly:!1,returnMode:m,isSQL92:t});if(p.changes.changes<0)throw new Error("Error in transaction method run ");r+=p.changes.changes}else{const m=await this.sqlite.execute({database:this.dbName,statements:o.statement,transaction:!1,readonly:!1});if(m.changes.changes<0)throw new Error("Error in transaction method execute ");r+=m.changes.changes}}const n=await this.sqlite.commitTransaction({database:this.dbName});r+=n.changes.changes;const a={changes:{changes:r}};return Promise.resolve(a)}catch(n){const a=n.message?n.message:n;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(a)}}async reorderRows(e){const t=e;if(e!=null&&e.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){const r=e.values[0].ios_columns,i=[];for(let n=1;n<e.values.length;n++){const a=e.values[n],o={};for(const m of r)o[m]=a[m];i.push(o)}t.values=i}return Promise.resolve(t)}}const le=oe("CapacitorSQLite",{web:()=>ie(()=>import("./Bc_z7frc.js"),__vite__mapDeps([0,1,2,3]),import.meta.url).then(d=>new d.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});function te(d){return d&&d.__esModule&&Object.prototype.hasOwnProperty.call(d,"default")?d.default:d}function ue(d){if(Object.prototype.hasOwnProperty.call(d,"__esModule"))return d;var e=d.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(d).forEach(function(r){var i=Object.getOwnPropertyDescriptor(d,r);Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:function(){return d[r]}})}),t}var C={},T={},Q;function re(){if(Q)return T;Q=1,Object.defineProperty(T,"__esModule",{value:!0}),T.formatError=void 0;function d(e){if(e instanceof Error)return e;if(typeof e=="object"){const t=new Error;for(let r in e)t[r]=e[r];return e.message&&(t.message=e.message),t}return typeof e=="string"?new Error(e):new Error(e)}return T.formatError=d,T}var z;function ne(){if(z)return C;z=1,Object.defineProperty(C,"__esModule",{value:!0}),C.Statement=void 0;const d=re();let e=class{constructor(r){this.stmt=r}getStatementInstance(){return this.stmt}bind(...r){return new Promise((i,n)=>{this.stmt.bind(...r,a=>{if(a)return n((0,d.formatError)(a));i()})})}reset(){return new Promise(r=>{this.stmt.reset(()=>{r()})})}finalize(){return new Promise((r,i)=>{this.stmt.finalize(n=>{if(n)return i((0,d.formatError)(n));r()})})}run(...r){return new Promise((i,n)=>{const a=this;this.stmt.run(...r,function(o){if(o)return n((0,d.formatError)(o));i({stmt:a,lastID:this.lastID,changes:this.changes})})})}get(...r){return new Promise((i,n)=>{this.stmt.get(...r,(a,o)=>{if(a)return n((0,d.formatError)(a));i(o)})})}all(...r){return new Promise((i,n)=>{this.stmt.all(...r,(a,o)=>{if(a)return n((0,d.formatError)(a));i(o)})})}each(...r){return new Promise((i,n)=>{const a=r.pop();if(!a||typeof a!="function")throw new Error("sqlite: Last param of Statement#each() must be a callback function");if(r.length>0){const o=r.pop();if(typeof o=="function")throw new Error("sqlite: Statement#each() should only have a single callback defined. See readme for usage.");r.push(o)}this.stmt.each(...r,(o,m)=>{if(o)return a((0,d.formatError)(o),null);a(null,m)},(o,m)=>{if(o)return n((0,d.formatError)(o));i(m)})})}};return C.Statement=e,C}ne();var R={},N={};const fe={},de=Object.freeze(Object.defineProperty({__proto__:null,default:fe},Symbol.toStringTag,{value:"Module"})),D=ue(de);var K;function he(){if(K)return N;K=1,Object.defineProperty(N,"__esModule",{value:!0}),N.migrate=N.readMigrations=void 0;const d=D,e=D;async function t(i){const n=i||e.join(process.cwd(),"migrations"),a=e.resolve(n),o=await new Promise((m,p)=>{d.readdir(a,(g,h)=>{if(g)return p(g);m(h.map(s=>s.match(/^(\d+).(.*?)\.sql$/)).filter(s=>s!==null).map(s=>({id:Number(s[1]),name:s[2],filename:s[0]})).sort((s,u)=>Math.sign(s.id-u.id)))})});if(!o.length)throw new Error(`No migration files found in '${a}'.`);return Promise.all(o.map(m=>new Promise((p,g)=>{const h=e.join(a,m.filename);d.readFile(h,"utf-8",(s,u)=>{if(s)return g(s);const[P,w]=u.split(/^--\s+?down\b/im),_=m;_.up=P.replace(/^-- .*?$/gm,"").trim(),_.down=w?w.trim():"",p(_)})})))}N.readMigrations=t;async function r(i,n={}){n.force=n.force||!1,n.table=n.table||"migrations";const{force:a,table:o}=n,m=n.migrations?n.migrations:await t(n.migrationsPath);await i.run(`CREATE TABLE IF NOT EXISTS "${o}" (
  id   INTEGER PRIMARY KEY,
  name TEXT    NOT NULL,
  up   TEXT    NOT NULL,
  down TEXT    NOT NULL
)`);let p=await i.all(`SELECT id, name, up, down FROM "${o}" ORDER BY id ASC`);const g=m[m.length-1];for(const s of p.slice().sort((u,P)=>Math.sign(P.id-u.id)))if(!m.some(u=>u.id===s.id)||a&&s.id===g.id){await i.run("BEGIN");try{await i.exec(s.down),await i.run(`DELETE FROM "${o}" WHERE id = ?`,s.id),await i.run("COMMIT"),p=p.filter(u=>u.id!==s.id)}catch(u){throw await i.run("ROLLBACK"),u}}else break;const h=p.length?p[p.length-1].id:0;for(const s of m)if(s.id>h){await i.run("BEGIN");try{await i.exec(s.up),await i.run(`INSERT INTO "${o}" (id, name, up, down) VALUES (?, ?, ?, ?)`,s.id,s.name,s.up,s.down),await i.run("COMMIT")}catch(u){throw await i.run("ROLLBACK"),u}}}return N.migrate=r,N}var x={},G;function me(){if(G)return x;G=1,Object.defineProperty(x,"__esModule",{value:!0}),x.toSqlParams=void 0;function d(e,t=[]){return typeof e=="string"?{sql:e,params:t}:{sql:e.sql,params:e.values}}return x.toSqlParams=d,x}var J;function ye(){if(J)return R;J=1,Object.defineProperty(R,"__esModule",{value:!0}),R.Database=void 0;const d=ne(),e=he(),t=me(),r=re();class i{constructor(a){this.config=a,this.db=null}on(a,o){this.db.on(a,o)}getDatabaseInstance(){return this.db}open(){return new Promise((a,o)=>{let{filename:m,mode:p,driver:g}=this.config;if(m==null)throw new Error("sqlite: filename cannot be null / undefined");if(!g)throw new Error("sqlite: driver is not defined");p?this.db=new g(m,p,h=>{if(h)return o((0,r.formatError)(h));a()}):this.db=new g(m,h=>{if(h)return o((0,r.formatError)(h));a()})})}close(){return new Promise((a,o)=>{this.db.close(m=>{if(m)return o((0,r.formatError)(m));a()})})}configure(a,o){this.db.configure(a,o)}run(a,...o){return new Promise((m,p)=>{const g=(0,t.toSqlParams)(a,o);this.db.run(g.sql,...g.params,function(h){if(h)return p((0,r.formatError)(h));m({stmt:new d.Statement(this.stmt),lastID:this.lastID,changes:this.changes})})})}get(a,...o){return new Promise((m,p)=>{const g=(0,t.toSqlParams)(a,o);this.db.get(g.sql,...g.params,(h,s)=>{if(h)return p((0,r.formatError)(h));m(s)})})}each(a,...o){return new Promise((m,p)=>{const g=o.pop();if(!g||typeof g!="function")throw new Error("sqlite: Last param of Database#each() must be a callback function");if(o.length>0){const s=o.pop();if(typeof s=="function")throw new Error("sqlite: Database#each() should only have a single callback defined. See readme for usage.");o.push(s)}const h=(0,t.toSqlParams)(a,o);this.db.each(h.sql,...h.params,(s,u)=>{if(s)return g((0,r.formatError)(s),null);g(null,u)},(s,u)=>{if(s)return p((0,r.formatError)(s));m(u)})})}all(a,...o){return new Promise((m,p)=>{const g=(0,t.toSqlParams)(a,o);this.db.all(g.sql,...g.params,(h,s)=>{if(h)return p((0,r.formatError)(h));m(s)})})}exec(a){return new Promise((o,m)=>{const p=(0,t.toSqlParams)(a);this.db.exec(p.sql,g=>{if(g)return m((0,r.formatError)(g));o()})})}prepare(a,...o){return new Promise((m,p)=>{const g=(0,t.toSqlParams)(a,o),h=this.db.prepare(g.sql,...g.params,s=>{if(s)return p(s);m(new d.Statement(h))})})}loadExtension(a){return new Promise((o,m)=>{this.db.loadExtension(a,p=>{if(p)return m((0,r.formatError)(p));o()})})}async migrate(a){await(0,e.migrate)(this,a)}serialize(){throw new Error("sqlite: Currently not implemented. Use getDatabaseInstance().serialize() instead.")}parallelize(){throw new Error("sqlite: Currently not implemented. Use getDatabaseInstance().parallelize() instead.")}}return R.Database=i,R}var pe=ye();const ve=te(pe);async function ge(d){const e=new ve.Database(d);return await e.open(),e}var A={exports:{}};function be(d){throw new Error('Could not dynamically require "'+d+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var k={exports:{}},I,V;function we(){if(V)return I;V=1;var d=D.sep||"/";I=e;function e(t){if(typeof t!="string"||t.length<=7||t.substring(0,7)!="file://")throw new TypeError("must pass in a file:// URI to convert to a file path");var r=decodeURI(t.substring(7)),i=r.indexOf("/"),n=r.substring(0,i),a=r.substring(i+1);return n=="localhost"&&(n=""),n&&(n=d+d+n),a=a.replace(/^(.+)\|/,"$1:"),d=="\\"&&(a=a.replace(/\//g,"\\")),/^.+\:/.test(a)||(a=d+a),n+a}return I}var H;function Pe(){return H||(H=1,(function(d,e){var t={},r=D,i=D,n=we(),a=i.join,o=i.dirname,m=r.accessSync&&function(h){try{r.accessSync(h)}catch{return!1}return!0}||r.existsSync||i.existsSync,p={arrow:t.NODE_BINDINGS_ARROW||" â†’ ",compiled:t.NODE_BINDINGS_COMPILED_DIR||"compiled",platform:process.platform,arch:process.arch,nodePreGyp:"node-v"+process.versions.modules+"-"+process.platform+"-"+process.arch,version:process.versions.node,bindings:"bindings.node",try:[["module_root","build","bindings"],["module_root","build","Debug","bindings"],["module_root","build","Release","bindings"],["module_root","out","Debug","bindings"],["module_root","Debug","bindings"],["module_root","out","Release","bindings"],["module_root","Release","bindings"],["module_root","build","default","bindings"],["module_root","compiled","version","platform","arch","bindings"],["module_root","addon-build","release","install-root","bindings"],["module_root","addon-build","debug","install-root","bindings"],["module_root","addon-build","default","install-root","bindings"],["module_root","lib","binding","nodePreGyp","bindings"]]};function g(h){typeof h=="string"?h={bindings:h}:h||(h={}),Object.keys(p).map(function(E){E in h||(h[E]=p[E])}),h.module_root||(h.module_root=e.getRoot(e.getFileName())),i.extname(h.bindings)!=".node"&&(h.bindings+=".node");for(var s=typeof __webpack_require__=="function"?__non_webpack_require__:be,u=[],P=0,w=h.try.length,_,j,L;P<w;P++){_=a.apply(null,h.try[P].map(function(E){return h[E]||E})),u.push(_);try{return j=h.path?s.resolve(_):s(_),h.path||(j.path=_),j}catch(E){if(E.code!=="MODULE_NOT_FOUND"&&E.code!=="QUALIFIED_PATH_RESOLUTION_FAILED"&&!/not find/i.test(E.message))throw E}}throw L=new Error(`Could not locate the bindings file. Tried:
`+u.map(function(E){return h.arrow+E}).join(`
`)),L.tries=u,L}d.exports=e=g,e.getFileName=function(s){var u=Error.prepareStackTrace,P=Error.stackTraceLimit,w={},_;Error.stackTraceLimit=10,Error.prepareStackTrace=function(L,E){for(var c=0,l=E.length;c<l;c++)if(_=E[c].getFileName(),_!==__filename)if(s){if(_!==s)return}else return},Error.captureStackTrace(w),w.stack,Error.prepareStackTrace=u,Error.stackTraceLimit=P;var j="file://";return _.indexOf(j)===0&&(_=n(_)),_},e.getRoot=function(s){for(var u=o(s),P;;){if(u==="."&&(u=process.cwd()),m(a(u,"package.json"))||m(a(u,"node_modules")))return u;if(P===u)throw new Error('Could not find module root given file: "'+s+'". Do you have a `package.json` file? ');P=u,u=a(u,"..")}}})(k,k.exports)),k.exports}var $,X;function _e(){return X||(X=1,$=Pe()("node_sqlite3.node")),$}var M={exports:{}},Y;function Ee(){if(Y)return M.exports;Y=1;var d=typeof Reflect=="object"?Reflect:null,e=d&&typeof d.apply=="function"?d.apply:function(l,f,y){return Function.prototype.apply.call(l,f,y)},t;d&&typeof d.ownKeys=="function"?t=d.ownKeys:Object.getOwnPropertySymbols?t=function(l){return Object.getOwnPropertyNames(l).concat(Object.getOwnPropertySymbols(l))}:t=function(l){return Object.getOwnPropertyNames(l)};function r(c){console&&console.warn&&console.warn(c)}var i=Number.isNaN||function(l){return l!==l};function n(){n.init.call(this)}M.exports=n,M.exports.once=j,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._eventsCount=0,n.prototype._maxListeners=void 0;var a=10;function o(c){if(typeof c!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof c)}Object.defineProperty(n,"defaultMaxListeners",{enumerable:!0,get:function(){return a},set:function(c){if(typeof c!="number"||c<0||i(c))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+c+".");a=c}}),n.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},n.prototype.setMaxListeners=function(l){if(typeof l!="number"||l<0||i(l))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+l+".");return this._maxListeners=l,this};function m(c){return c._maxListeners===void 0?n.defaultMaxListeners:c._maxListeners}n.prototype.getMaxListeners=function(){return m(this)},n.prototype.emit=function(l){for(var f=[],y=1;y<arguments.length;y++)f.push(arguments[y]);var v=l==="error",q=this._events;if(q!==void 0)v=v&&q.error===void 0;else if(!v)return!1;if(v){var b;if(f.length>0&&(b=f[0]),b instanceof Error)throw b;var S=new Error("Unhandled error."+(b?" ("+b.message+")":""));throw S.context=b,S}var O=q[l];if(O===void 0)return!1;if(typeof O=="function")e(O,this,f);else for(var U=O.length,se=P(O,U),y=0;y<U;++y)e(se[y],this,f);return!0};function p(c,l,f,y){var v,q,b;if(o(f),q=c._events,q===void 0?(q=c._events=Object.create(null),c._eventsCount=0):(q.newListener!==void 0&&(c.emit("newListener",l,f.listener?f.listener:f),q=c._events),b=q[l]),b===void 0)b=q[l]=f,++c._eventsCount;else if(typeof b=="function"?b=q[l]=y?[f,b]:[b,f]:y?b.unshift(f):b.push(f),v=m(c),v>0&&b.length>v&&!b.warned){b.warned=!0;var S=new Error("Possible EventEmitter memory leak detected. "+b.length+" "+String(l)+" listeners added. Use emitter.setMaxListeners() to increase limit");S.name="MaxListenersExceededWarning",S.emitter=c,S.type=l,S.count=b.length,r(S)}return c}n.prototype.addListener=function(l,f){return p(this,l,f,!1)},n.prototype.on=n.prototype.addListener,n.prototype.prependListener=function(l,f){return p(this,l,f,!0)};function g(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function h(c,l,f){var y={fired:!1,wrapFn:void 0,target:c,type:l,listener:f},v=g.bind(y);return v.listener=f,y.wrapFn=v,v}n.prototype.once=function(l,f){return o(f),this.on(l,h(this,l,f)),this},n.prototype.prependOnceListener=function(l,f){return o(f),this.prependListener(l,h(this,l,f)),this},n.prototype.removeListener=function(l,f){var y,v,q,b,S;if(o(f),v=this._events,v===void 0)return this;if(y=v[l],y===void 0)return this;if(y===f||y.listener===f)--this._eventsCount===0?this._events=Object.create(null):(delete v[l],v.removeListener&&this.emit("removeListener",l,y.listener||f));else if(typeof y!="function"){for(q=-1,b=y.length-1;b>=0;b--)if(y[b]===f||y[b].listener===f){S=y[b].listener,q=b;break}if(q<0)return this;q===0?y.shift():w(y,q),y.length===1&&(v[l]=y[0]),v.removeListener!==void 0&&this.emit("removeListener",l,S||f)}return this},n.prototype.off=n.prototype.removeListener,n.prototype.removeAllListeners=function(l){var f,y,v;if(y=this._events,y===void 0)return this;if(y.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):y[l]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete y[l]),this;if(arguments.length===0){var q=Object.keys(y),b;for(v=0;v<q.length;++v)b=q[v],b!=="removeListener"&&this.removeAllListeners(b);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(f=y[l],typeof f=="function")this.removeListener(l,f);else if(f!==void 0)for(v=f.length-1;v>=0;v--)this.removeListener(l,f[v]);return this};function s(c,l,f){var y=c._events;if(y===void 0)return[];var v=y[l];return v===void 0?[]:typeof v=="function"?f?[v.listener||v]:[v]:f?_(v):P(v,v.length)}n.prototype.listeners=function(l){return s(this,l,!0)},n.prototype.rawListeners=function(l){return s(this,l,!1)},n.listenerCount=function(c,l){return typeof c.listenerCount=="function"?c.listenerCount(l):u.call(c,l)},n.prototype.listenerCount=u;function u(c){var l=this._events;if(l!==void 0){var f=l[c];if(typeof f=="function")return 1;if(f!==void 0)return f.length}return 0}n.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};function P(c,l){for(var f=new Array(l),y=0;y<l;++y)f[y]=c[y];return f}function w(c,l){for(;l+1<c.length;l++)c[l]=c[l+1];c.pop()}function _(c){for(var l=new Array(c.length),f=0;f<l.length;++f)l[f]=c[f].listener||c[f];return l}function j(c,l){return new Promise(function(f,y){function v(b){c.removeListener(l,q),y(b)}function q(){typeof c.removeListener=="function"&&c.removeListener("error",v),f([].slice.call(arguments))}E(c,l,q,{once:!0}),l!=="error"&&L(c,v,{once:!0})})}function L(c,l,f){typeof c.on=="function"&&E(c,"error",l,f)}function E(c,l,f,y){if(typeof c.on=="function")y.once?c.once(l,f):c.on(l,f);else if(typeof c.addEventListener=="function")c.addEventListener(l,function v(q){y.once&&c.removeEventListener(l,v),f(q)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof c)}return M.exports}var F={},Z;function qe(){if(Z)return F;Z=1;const d=D;function e(r,i,n){const a=r[i];r[i]=function(){const o=new Error,m=r.constructor.name+"#"+i+"("+Array.prototype.slice.call(arguments).map(function(g){return d.inspect(g,!1,0)}).join(", ")+")";typeof n>"u"&&(n=-1),n<0&&(n+=arguments.length);const p=arguments[n];return typeof arguments[n]=="function"&&(arguments[n]=function(){const h=arguments[0];return h&&h.stack&&!h.__augmented&&(h.stack=t(h).join(`
`),h.stack+=`
--> in `+m,h.stack+=`
`+t(o).slice(1).join(`
`),h.__augmented=!0),p.apply(this,arguments)}),a.apply(this,arguments)}}F.extendTrace=e;function t(r){return r.stack.split(`
`).filter(function(i){return i.indexOf(__filename)<0})}return F}var ee;function je(){return ee||(ee=1,(function(d,e){const t=D,r=_e(),i=Ee().EventEmitter;d.exports=r;function n(s){return function(u){let P;const w=Array.prototype.slice.call(arguments,1);if(typeof w[w.length-1]=="function"){const j=w[w.length-1];P=function(L){L&&j(L)}}const _=new m(this,u,P);return s.call(this,_,w)}}function a(s,u){for(const P in u.prototype)s.prototype[P]=u.prototype[P]}r.cached={Database:function(s,u,P){if(s===""||s===":memory:")return new o(s,u,P);let w;if(s=t.resolve(s),!r.cached.objects[s])w=r.cached.objects[s]=new o(s,u,P);else{w=r.cached.objects[s];const _=typeof u=="number"?P:u;if(typeof _=="function"){let j=function(){_.call(w,null)};w.open?process.nextTick(j):w.once("open",j)}}return w},objects:{}};const o=r.Database,m=r.Statement,p=r.Backup;a(o,i),a(m,i),a(p,i),o.prototype.prepare=n(function(s,u){return u.length?s.bind.apply(s,u):s}),o.prototype.run=n(function(s,u){return s.run.apply(s,u).finalize(),this}),o.prototype.get=n(function(s,u){return s.get.apply(s,u).finalize(),this}),o.prototype.all=n(function(s,u){return s.all.apply(s,u).finalize(),this}),o.prototype.each=n(function(s,u){return s.each.apply(s,u).finalize(),this}),o.prototype.map=n(function(s,u){return s.map.apply(s,u).finalize(),this}),o.prototype.backup=function(){let s;return arguments.length<=2?s=new p(this,arguments[0],"main","main",!0,arguments[1]):s=new p(this,arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]),s.retryErrors=[r.BUSY,r.LOCKED],s},m.prototype.map=function(){const s=Array.prototype.slice.call(arguments),u=s.pop();return s.push(function(P,w){if(P)return u(P);const _={};if(w.length){const j=Object.keys(w[0]),L=j[0];if(j.length>2)for(let E=0;E<w.length;E++)_[w[E][L]]=w[E];else{const E=j[1];for(let c=0;c<w.length;c++)_[w[c][L]]=w[c][E]}}u(P,_)}),this.all.apply(this,s)};let g=!1;const h=["trace","profile","change"];o.prototype.addListener=o.prototype.on=function(s){const u=i.prototype.addListener.apply(this,arguments);return h.indexOf(s)>=0&&this.configure(s,!0),u},o.prototype.removeListener=function(s){const u=i.prototype.removeListener.apply(this,arguments);return h.indexOf(s)>=0&&!this._events[s]&&this.configure(s,!1),u},o.prototype.removeAllListeners=function(s){const u=i.prototype.removeAllListeners.apply(this,arguments);return h.indexOf(s)>=0&&this.configure(s,!1),u},r.verbose=function(){if(!g){const s=qe();["prepare","get","run","all","each","map","close","exec"].forEach(function(u){s.extendTrace(o.prototype,u)}),["bind","get","run","all","each","map","reset","finalize"].forEach(function(u){s.extendTrace(m.prototype,u)}),g=!0}return r}})(A)),A.exports}var Le=je();const B=te(Le);class Se{constructor(e){this.db=e}async exec(e){await this.db.execute(e)}async run(e,t=[]){await this.db.run(e,t)}async get(e,t=[]){var i;return(i=(await this.db.query(e,t)).values)==null?void 0:i[0]}async all(e,t=[]){return(await this.db.query(e,t)).values||[]}async close(){await this.db.close()}}class Ne{constructor(e){this.db=e}async exec(e){await this.db.exec(e)}async run(e,t=[]){await this.db.run(e,...t)}async get(e,t=[]){return this.db.get(e,...t)}async all(e,t=[]){return this.db.all(e,...t)}async close(){await this.db.close()}}async function Te(d){if(ae.isNativePlatform()){const t=new ce(le);await t.checkConnectionsConsistency(),(await t.isConnection(d,!1)).result&&await t.closeConnection(d,!1),await t.createConnection(d,!1,"no-encryption",1,!1);const i=await t.retrieveConnection(d,!1);return new Se(i)}const e=await ge({filename:`${d}.sqlite`,driver:B.Database,mode:B.OPEN_READWRITE+B.OPEN_CREATE});return new Ne(e)}export{Te as default};
